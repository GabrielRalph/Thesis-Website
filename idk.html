<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 226.14 254.98">
  <!-- Generator: Adobe Illustrator 29.7.1, SVG Export Plug-In . SVG Version: 2.1.1 Build 8)  -->
  <path d="M0,58.36c6.04-.92,12.86-1.66,17.65,2.12,2.24,1.77,3.74,4.33,5.94,6.16,3.99,3.32,10.08,3.66,14.59,1.11s7.32-7.72,7.37-12.91c.05-5.55-2.73-10.76-3.31-16.28-.59-5.58,1.28-11.49,5.36-15.35s10.39-5.37,15.61-3.31c5.93,2.34,9.5,8.62,10.67,14.89.92,4.97.62,10.17-.88,14.99-1.05,3.39-2.68,6.63-3.12,10.16-.86,6.99,3.19,13.7,8.14,18.7,11.3,11.42,28.32,16.87,44.15,14.14,2.07-.36,4.18-.87,5.88-2.09,2.28-1.63,3.55-4.29,5.15-6.59,5.22-7.49,14.98-11.53,23.97-9.91,1.2.22,2.41.54,3.38,1.27,3,2.27,2.19,6.84,1.98,10.59-.45,7.86,3.41,15.84,9.86,20.37,3.73,2.62,8.17,4.11,11.86,6.79s6.66,7.25,5.41,11.64c-3.51,5.19-10.28,7.1-16.54,7.38s-12.6-.69-18.76.43c-6.16,1.12-12.45,5.1-13.61,11.26-1.03,5.49,2.25,10.84,5.93,15.04,4.87,5.56,10.81,10.32,17.71,12.99,10.02,3.88,22.99,4.17,28.37,13.46,3.79,6.55,1.91,14.92,4.16,22.14,1.89,6.08,6.57,10.93,8.86,16.87,3.75,9.73.59,20.61-2.58,30.54" style="fill: none; stroke: #231f20; stroke-miterlimit: 10;"/>
</svg>
</body>
<script>
    const path = document.querySelector('path');
    const length = path.getTotalLength();
    const px2mm =  0.264583; // 1px = 0.264583 mm
    const points = new Array(Math.round(length * 2 * px2mm)).fill().map((_, i) => path.getPointAtLength(i / 2 / px2mm)).map(p => ({x: p.x, y: 254.98 - p.y}));
    
    
    const angles = points.map((p, i) => {
        return Math.atan2(p.y, p.x) * 180 / Math.PI;
    });

    console.log(angles)

    function intersept(m1, p1x, p1y, m2, p2x, p2y) {
        if (m1 == m2) return null; // parallel lines
        let x = 0;
        let y = 0;
        if (m1 == Infinity || m1 == -Infinity) {
            x = p1x;
            y = m2 * (x - p2x) + p2y;
            return {x, y};
        } else if (m2 == Infinity || m2 == -Infinity) {
            x = p2x;
            y = m1 * (x - p1x) + p1y;
            return {x, y};
        } else {
            let c1 = p1y - p1x * m1;
            let c2 = p2y - p2x * m2;
            x = (c1 - c2) / (m2 - m1);
            y = c1 + x * m1;
        }
        return {x, y};
    }

    
    function getFurthestPointOnLineAtAngle(theta) {
        let ip = [];
        for (let i = 1; i < angles.length; i++) {
            let a1 = angles[i - 1];
            let a2 = angles[i];
            if ((a1 <= theta && a2 >= theta) || (a1 >= theta && a2 <= theta)) {
                let m1 = Math.tan(theta * Math.PI / 180);
                let m2 = (points[i].y - points[i - 1].y) / (points[i].x - points[i - 1].x);
                let p = intersept(m1, 0, 0, m2, points[i - 1].x, points[i - 1].y);
                if (p) {
                    ip.push(p)
                }
            }
        }

        let maxi = 0;
        let maxP = null;
        ip.forEach(p => {
            let d = Math.sqrt(p.x * p.x + p.y * p.y);
            if (d > maxi) {
                maxi = d;
                maxP = p;
            }
        })

        return maxP;
    }


    let pointPrim = new Array(3000).fill(0).map((_, i) => getFurthestPointOnLineAtAngle(90 * i/999)).filter(p => p != null);

    

    // const dAngle = angles.map((angle, i, arr) => {
    //     if (i === 0) return 0;
    //     let diff = angle - arr[i - 1];
    //     return [diff, i];
    // });
    // // const nPos = dAngle.filter(angle => angle[0] > 0);
    // // const nNeg = dAngle.filter(angle => angle[0] < 0);
    // let segs = [];
    // let seg = [];
    // let dir = null;
    // for (let i = 0; i < dAngle.length; i++) {
    //     if (dir == null) dir = dAngle[i][0];
    //     else {
    //         if ((dAngle[i][0] > 0 && dir > 0) || (dAngle[i][0] < 0 && dir < 0)) {
    //             seg.push(dAngle[i]);
    //         } else {
    //             if (seg.length > 0) segs.push(seg);
    //             seg = [dAngle[i]];
    //             dir = dAngle[i][0];
    //         }
    //     }
    // }
    // if (seg.length > 0) segs.push(seg);

    const svg = document.querySelector('svg');
    // segs.forEach((seg, i) => {254.98 - p.y
    // let sp = seg.map(d => points[d[1]]);
    let pathStr = `M${pointPrim.map(p => `${p.x},${254.98 - p.y}`).join('L')}`;
    const newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    newPath.setAttribute('d', pathStr);
    newPath.setAttribute('style', `fill: none; stroke: ${true?"blue":"red"}; stroke-miterlimit: 10;`);
    svg.appendChild(newPath);
    // })

   

</script>
</html>